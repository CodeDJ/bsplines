#ifdef OPENGL_2
static const std::string vertexShaderCode =   "#version 110\n"
                                              ""
                                              "void main()\n"
                                              "{\n"
                                              "gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
                                              "}";


static const std::string fragmentShaderCode = "#version 110\n"
                                              ""
                                              "void main()\n"
                                              "{\n"
                                              "  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n"
                                              "}";
#else

static const std::string vertexShaderCode =   "#version 330\n"
                                              "layout (location = 0 ) in vec2 VertexPosition;\n"
        "out vec3 SegmentColor;\n"
                                              "void main()\n"
                                              "{\n"
                                              "gl_Position = vec4(VertexPosition, 0.0, 1.0);\n"
        "SegmentColor = vec3(1.0, 1.0, 1.0);"
                                              "}";


static const std::string fragmentShaderCode = "#version 330\n"
                                              "in vec3 SegmentColor;\n"
                                              "uniform vec4 curbColor;\n"
                                              "layout ( location = 0 ) out vec4 FragColor;\n"
                                              "void main()\n"
                                              "{\n"
                                              "  //FragColor = vec4(SegmentColor, 0.5); \n"
                                              "  FragColor = curbColor; \n"
                                              "}";

static const std::string TCShaderCode = ""
                                        "#version 150\n"
                                        "layout( vertices=13 ) out;\n"
                                        "uniform int numSegments = 30;\n"
                                        "uniform int numStrips = 3;\n"
                                        "void main() {\n"
                                                   "// Pass along the vertex position unmodified\n"
                                                   "gl_out[gl_InvocationID].gl_Position =\n"
                                                             "gl_in[gl_InvocationID].gl_Position;\n"
                                                   "// Define the tessellation levels (this works on\n"
                                                   "// ATI Catalyst drivers as of this writing, you may\n"
                                                   "// need to swap these)\n"
                                                   "gl_TessLevelOuter[0] = float(numStrips);\n"
                                                   "gl_TessLevelOuter[1] = float(numSegments);\n"
                                        "}\n";

/*
static const std::string TEShaderCode = ""
                                        "#version 400\n"
                                           "layout( isolines ) in;\n"
                                           "//uniform mat4 MVP;  // projection * view * model\n"
                                        "void main() {\n"
                                               "// The tessellation u coordinate\n"
                                               "float u = gl_TessCoord.x;\n"
                                               "// The patch vertices (control points)\n"
                                               "vec3 p0 = gl_in[0].gl_Position.xyz;\n"
                                               "vec3 p1 = gl_in[1].gl_Position.xyz;\n"
                                               "vec3 p2 = gl_in[2].gl_Position.xyz;\n"
                                               "vec3 p3 = gl_in[3].gl_Position.xyz;\n"
                                               "float u1 = (1.0 - u);\n"
                                               "float u2 = u * u;\n"
                                               "// Bernstein polynomials evaluated at u\n"
                                               "float b3 = u2 * u;\n"
                                               "float b2 = 3.0 * u2 * u1;\n"
                                               "float b1 = 3.0 * u * u1 * u1;\n"
                                               "float b0 = u1 * u1 * u1;\n"
                                               "// Cubic Bezier interpolation\n"
                                               "vec3 p = p0 * b0 + p1 * b1 + p2 * b2 + p3 * b3;\n"
                                               "gl_Position = vec4(p, 1.0);//MVP * \n"
                                           "}\n";
*/
static const std::string TEShaderCode = ""
                                        "#version 150\n"
                                           "layout( isolines ) in;\n"
                                           "uniform int numStrips = 3;\n"
                                            "out vec3 tesSegmentColor;\n"
        "vec3 quadratic_bezier(vec3 p0, vec3 p1, vec3 p2, float u)\n"
        "{\n"
        "vec3 p01 = mix(p0, p1, u);\n"
        "vec3 p12 = mix(p1, p2, u);\n"
        "vec3 p = mix(p01, p12, u);\n"
        "return p;\n"
        "}\n"
        "vec3 cubic_bezier(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float u)\n"
        "{\n"
        "vec3 p01 = mix(p0, p1, u);\n"
        "vec3 p12 = mix(p1, p2, u);\n"
        "vec3 p23 = mix(p2, p3, u);\n"
        "return quadratic_bezier(p01, p12, p23, u);\n"
        "}\n"
        "vec3 cubic_bspline(vec3 p[4], float u)\n"
        "{\n"
        "if (u <= 0.0) return p[0];\n"
        "if (u >= 1.0) return p[3];\n"
        "return cubic_bezier(p[0], p[1], p[2], p[3], u);\n"
        "}\n"
        "vec3 evaluateBezierPosition( vec3 v[4], float t )"
        "{"
        "   float OneMinusT = 1.0 - t;"
        "   float b0 = OneMinusT*OneMinusT*OneMinusT;"
        "   float b1 = 3.0*t*OneMinusT*OneMinusT;"
        "   float b2 = 3.0*t*t*OneMinusT;"
        "   float b3 = t*t*t;"
        "   return b0*v[0] + b1*v[1] + b2*v[2] + b3*v[3];"
        "}\n"
                                        "void main() {\n"
                                                "// The tessellation u coordinate\n"
                                                "float u = gl_TessCoord.x;\n"
                                                "int step = int(floor(100.0/numStrips));\n"
                                                "int v = int(floor(gl_TessCoord.y*100.0))/step;\n"
                                                "//// The patch vertices (control points)\n"
                                                "vec3 p[4]; \n"
                                                "for (int i=0; i<4; ++i) p[i] = gl_in[v*3+i].gl_Position.xyz;\n"
                                                "// Cubic Bezier interpolation\n"
                                                "vec3 pf = cubic_bspline(p, u);\n"
                                                "//vec3 pf = evaluateBezierPosition(p, u);\n"
                                                "gl_Position = vec4(pf, 1.0); \n"
                                                "if (v==0) tesSegmentColor = vec3(1.0, 0.0, 0.0);\n"
                                                "else if (v==1) tesSegmentColor = vec3(0.0, 1.0, 0.0);\n"
                                                "else if (v==2) tesSegmentColor = vec3(0.0, 0.0, 1.0);\n"
                                                "else if (v==3) tesSegmentColor = vec3(1.0, 1.0, 0.0);\n"
                                                "else tesSegmentColor = vec3(1.0, 1.0, 1.0);\n"
                                           "}\n";

/*
"vec3 p[3*];\n"
"p[0] = gl_in[0].gl_Position.xyz;\n"
"p[1] = gl_in[1].gl_Position.xyz;\n"
"p[2] = gl_in[2].gl_Position.xyz;\n"
"p[3] = gl_in[3].gl_Position.xyz;\n"
"p[4] = gl_in[4].gl_Position.xyz;\n"
"p[5] = gl_in[5].gl_Position.xyz;\n"
"p[6] = gl_in[6].gl_Position.xyz;\n"
"p[7] = gl_in[7].gl_Position.xyz;\n"
"p[8] = gl_in[8].gl_Position.xyz;\n"
"p[9] = gl_in[9].gl_Position.xyz;\n"
"//p[10] = gl_in[10].gl_Position.xyz;\n"
"//p[11] = gl_in[11].gl_Position.xyz;\n"
"//p[12] = gl_in[12].gl_Position.xyz;\n"
*/
/*
static const std::string TEShaderCode = ""
                                        "#version 400\n"
                                           "layout( isolines ) in;\n"
                                           "//uniform mat4 MVP;  // projection * view * model\n"
                                        "void main() {\n"
                                                "float u = gl_TessCoord.x;\n"
                                                "vec3 p0 = gl_in[0].gl_Position.xyz;\n"
                                               "gl_Position = vec4(p0*u, 1.0);//MVP * \n"
                                           "}\n";
*/


static const std::string geomShaderCode =
                                            "#version 400\n"
                                            "layout (lines) in;\n"
                                            "layout (triangle_strip, max_vertices = 4) out;\n"
                                            "in vec3 tesSegmentColor[];\n"
                                            "out vec3 SegmentColor;\n"
                                            "uniform float lineWidthAlphaX = 0.003;"
                                            "uniform float lineWidthAlphaY = 0.003;"
                                            "void main()\n"
                                            "{\n"
                                            "SegmentColor = tesSegmentColor[0];\n"
                                            "float pixels = 0.003; \n"
                                            "vec3 v = gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz;\n"
                                            "vec4 n1 = vec4(normalize(vec3(-v.y, v.x, 0.0)), 0.0);\n"
                                            "vec4 n2 = vec4(normalize(vec3(v.y, -v.x, 0.0)), 0.0);\n"
                                            "n1.x = n1.x * lineWidthAlphaX / 2; \n"
                                            "n1.y = n1.y * lineWidthAlphaY / 2; \n"
                                            "n2.x = n2.x * lineWidthAlphaX / 2; \n"
                                            "n2.y = n2.y * lineWidthAlphaY / 2; \n"
                                            "gl_Position = gl_in[0].gl_Position + n2;//lineWidthAlphaX*n2;\n"
                                            "EmitVertex();\n"
                                            "gl_Position = gl_in[0].gl_Position + n1;//lineWidthAlpha*n1;\n"
                                            "EmitVertex();\n"
                                            "gl_Position= gl_in[1].gl_Position + n2;//lineWidthAlpha*n2;\n"
                                            "EmitVertex();\n"
                                            "gl_Position = gl_in[1].gl_Position + n1;//lineWidthAlpha*n1;\n"
                                            "EmitVertex();\n"
                                            "}";

/*
static const std::string geomShaderCode =
                                            "#version 150\n"
                                            "layout (lines) in;\n"
                                            "layout (line_strip, max_vertices = 2) out;\n"
                                            "void main()\n"
                                            "{\n"
                                                "for(int i=0; i<gl_in.length(); ++i) { gl_Position = gl_in[i].gl_Position; EmitVertex(); }\n"
                                                "EndPrimitive();\n"
                                            "}";
*/


static const std::string geomShaderCode1 =
                                            "#version 150\n"
                                            "layout (lines) in;\n"
                                            "layout (triangle_strip) out;\n"
                                            "uniform vec2 ControlPoints[13];"
        "uniform float lineWidthAlphaX = 0.003;"
        "uniform float lineWidthAlphaY = 0.003;"
                                            "layout(max_vertices = 1024) out;\n"
        "vec3 quadratic_bezier(vec3 p0, vec3 p1, vec3 p2, float u)\n"
        "{\n"
        "   vec3 p01 = mix(p0, p1, u);\n"
        "   vec3 p12 = mix(p1, p2, u);\n"
        "   vec3 p = mix(p01, p12, u);\n"
        "   return p;\n"
        "}\n"
        "vec3 cubic_bezier(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float u)\n"
        "{\n"
        "   vec3 p01 = mix(p0, p1, u);\n"
        "   vec3 p12 = mix(p1, p2, u);\n"
        "   vec3 p23 = mix(p2, p3, u);\n"
        "   return quadratic_bezier(p01, p12, p23, u);\n"
        "}\n"
        "vec3 cubic_bspline(vec3 p[4], float u)\n"
        "{\n"
        "   if (u <= 0.0) return p[0];\n"
        "   if (u >= 1.0) return p[3];\n"
        "   return cubic_bezier(p[0], p[1], p[2], p[3], u);\n"
        "}\n"

        "vec3 evaluateBezierPosition( vec3 v[4], float t )"
        "{"
        "   float OneMinusT = 1.0 - t;"
        "   float b0 = OneMinusT*OneMinusT*OneMinusT;"
        "   float b1 = 3.0*t*OneMinusT*OneMinusT;"
        "   float b2 = 3.0*t*t*OneMinusT;"
        "   float b3 = t*t*t;"
        "   return b0*v[0] + b1*v[1] + b2*v[2] + b3*v[3];"
        "}\n"

        "void process(vec3 p0, vec3 p1, bool all) {\n"
        "vec3 v = p1 - p0;\n"
        "vec4 n1 = vec4(normalize(vec3(-v.y, v.x, 0.0)), 0.0);\n"
        "vec4 n2 = vec4(normalize(vec3(v.y, -v.x, 0.0)), 0.0);\n"
        "n1.x = n1.x * lineWidthAlphaX / 2; \n"
        "n1.y = n1.y * lineWidthAlphaY / 2; \n"
        "n2.x = n2.x * lineWidthAlphaX / 2; \n"
        "n2.y = n2.y * lineWidthAlphaY / 2; \n"
        "gl_Position = vec4(p1, 1.0) + n2;//lineWidthAlpha*n2;\n"
        "EmitVertex();\n"
        "gl_Position = vec4(p1, 1.0) + n1;//lineWidthAlpha*n1;\n"
        "EmitVertex();\n"
        "}\n"

        "void process_all(vec3 p0, vec3 p1, bool all) {\n"
        "vec3 v = p1 - p0;\n"
        "vec4 n1 = vec4(normalize(vec3(-v.y, v.x, 0.0)), 0.0);\n"
        "vec4 n2 = vec4(normalize(vec3(v.y, -v.x, 0.0)), 0.0);\n"
        "n1.x = n1.x * lineWidthAlphaX / 2; \n"
        "n1.y = n1.y * lineWidthAlphaY / 2; \n"
        "n2.x = n2.x * lineWidthAlphaX / 2; \n"
        "n2.y = n2.y * lineWidthAlphaY / 2; \n"
        "gl_Position = vec4(p0, 1.0) + n2;//lineWidthAlphaX*n2;\n"
        "EmitVertex();\n"
        "gl_Position = vec4(p0, 1.0) + n1;//lineWidthAlpha*n1;\n"
        "EmitVertex();\n"
        "gl_Position = vec4(p1, 1.0) + n2;//lineWidthAlpha*n2;\n"
        "EmitVertex();\n"
        "gl_Position = vec4(p1, 1.0) + n1;//lineWidthAlpha*n1;\n"
        "EmitVertex();\n"
        "}\n"


        "void main()\n"
        "{\n"
        "vec3 p[4];\n"
        "vec3 prev, crt;\n"
        "float step = 1.0/30.0;\n"
        "for (int v=0; v<4; ++v) {"
        "   p[0] = vec3(ControlPoints[3*v], 0.0);"
        "   p[1] = vec3(ControlPoints[3*v + 1], 0.0);"
        "   p[2] = vec3(ControlPoints[3*v + 2], 0.0);"
        "   p[3] = vec3(ControlPoints[3*v + 3], 0.0);"
        "   float u = 0.0;"
        "   //prev = cubic_bspline(p, u);\n"
        "   prev = p[0];\n"
        "   u += step;\n"
        "   //crt = cubic_bspline(p, u);\n"
        "   crt = evaluateBezierPosition(p, u);\n"
        "   process_all(prev, crt, true);\n"
        "   prev = crt;\n"
        "   for(int j=2; j<30; ++j) { "
        "       u += step;\n"
        "       //crt = cubic_bspline(p, u);\n"
        "       crt = evaluateBezierPosition(p, u);\n"
        "       process(prev, crt, false);"
        "       prev = crt;"
        "   }\n"
        "   crt = p[3];\n"
        "   process(prev, crt, false);"
        "}\n"
        "EndPrimitive();\n"
                                            "}";
///
/*
"//process(prev, vec3(ControlPoints[12], 0.0), false);\n"
*/

#endif

//static void printOpenGLError(int error, const char* message)
//{
//    printf("[ERR]: %s - OpenGL_Error: %s\n", message ? message : "", gluErrorString(static_cast<GLenum>(error)));
//}

//static void ifOpenGLErrorCloseAndExit(void (*close)(), const char* message /*= 0*/)
//{
//    GLenum error = glGetError();
//    if (GL_NO_ERROR == error)
//        return;
//    printOpenGLError(error, message);
//    close();
//    exit(0);
//}
